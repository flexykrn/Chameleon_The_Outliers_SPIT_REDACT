import { NextResponse } from 'next/server';
import { db } from '@/app/firebase';
import { collection, query, orderBy, limit, getDocs, addDoc, serverTimestamp } from 'firebase/firestore';
import { generateMerkleRoot } from '@/lib/merkle';
import { anchorMerkleRoot, isBlockchainConfigured } from '@/lib/blockchain';

/**
 * Automatic Batch Anchoring Service
 * This API can be called periodically (via cron job) to automatically
 * anchor attack logs to the blockchain
 */
export async function POST(request) {
  try {
    // Check if blockchain is configured
    if (!isBlockchainConfigured()) {
      return NextResponse.json({
        success: false,
        error: 'Blockchain not configured'
      }, { status: 503 });
    }

    // Get parameters
    const body = await request.json().catch(() => ({}));
    const { 
      batchSize = 50,  // Default to 50 logs per batch
      autoMode = true  // Auto mode generates timestamp-based batch ID
    } = body;

    console.log('ü§ñ Starting automatic batch anchoring...');

    // Fetch recent attack logs from Firebase
    const attacksRef = collection(db, 'attacks');
    const q = query(attacksRef, orderBy('timestamp', 'desc'), limit(batchSize));
    const snapshot = await getDocs(q);

    if (snapshot.empty) {
      return NextResponse.json({
        success: false,
        error: 'No attack logs found to anchor',
        autoRetry: true
      }, { status: 404 });
    }

    // Convert to array of log objects
    const attackLogs = [];
    const logIds = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      attackLogs.push({ id: doc.id, ...data });
      logIds.push(doc.id);
    });

    console.log(`üìä Found ${attackLogs.length} logs to anchor`);

    // Generate Merkle root
    const merkleRoot = generateMerkleRoot(attackLogs);
    console.log(`üå≥ Merkle root generated: ${merkleRoot}`);

    // Generate batch ID with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const batchId = `batch-${timestamp}-${attackLogs.length}`;

    // Anchor to blockchain
    console.log(`üîó Anchoring to blockchain...`);
    const anchorResult = await anchorMerkleRoot(batchId, merkleRoot);

    if (!anchorResult.success) {
      console.error('‚ùå Blockchain anchoring failed:', anchorResult.error);
      return NextResponse.json({
        success: false,
        error: 'Blockchain anchoring failed',
        details: anchorResult.error,
        autoRetry: true
      }, { status: 500 });
    }

    console.log(`‚úÖ Successfully anchored to blockchain!`);

    // Store batch metadata in Firebase
    try {
      const batchMetadata = {
        batchId,
        merkleRoot,
        logCount: attackLogs.length,
        logIds,
        transactionHash: anchorResult.transactionHash,
        blockNumber: anchorResult.blockNumber,
        timestamp: serverTimestamp(),
        timestampISO: new Date().toISOString(),
        autoGenerated: autoMode,
        status: 'anchored'
      };

      const batchRef = await addDoc(collection(db, 'blockchainBatches'), batchMetadata);
      console.log(`üíæ Batch metadata saved to Firebase: ${batchRef.id}`);
    } catch (firestoreError) {
      console.error('‚ö†Ô∏è Failed to save batch metadata:', firestoreError);
      // Continue anyway - blockchain anchor succeeded
    }

    // Return success with full details
    return NextResponse.json({
      success: true,
      message: 'Logs automatically anchored to blockchain',
      batch: {
        batchId,
        merkleRoot,
        logCount: attackLogs.length,
        logIds: logIds.slice(0, 5), // Return first 5 IDs for reference
        totalLogs: logIds.length
      },
      blockchain: {
        transactionHash: anchorResult.transactionHash,
        blockNumber: anchorResult.blockNumber,
        explorerUrl: anchorResult.explorerUrl
      },
      timestamp: new Date().toISOString(),
      autoMode: autoMode
    });

  } catch (error) {
    console.error('‚ùå Auto-anchoring error:', error);
    return NextResponse.json({
      success: false,
      error: 'Auto-anchoring failed',
      details: error.message,
      autoRetry: true
    }, { status: 500 });
  }
}

// Health check endpoint
export async function GET() {
  const configured = isBlockchainConfigured();
  
  return NextResponse.json({
    service: 'Automatic Batch Anchoring',
    status: configured ? 'ready' : 'not configured',
    configured,
    endpoint: '/api/auto-anchor',
    description: 'Automatically anchors attack logs to blockchain',
    recommendations: configured 
      ? 'Service is ready. Schedule POST requests to this endpoint.'
      : 'Configure NEXT_PUBLIC_LOG_ANCHOR_CONTRACT and BLOCKCHAIN_PRIVATE_KEY'
  });
}

export const runtime = 'nodejs';
